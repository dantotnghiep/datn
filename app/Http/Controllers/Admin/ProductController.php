<?php

namespace App\Http\Controllers\Admin;

use App\Models\Product;
use App\Models\Category;
use App\Models\ProductImage;
use App\Models\ProductVariation;
use App\Models\Attribute;
use App\Models\AttributeValue;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use App\Http\Controllers\Admin\Traits\HasUploadImage;

class ProductController extends BaseController
{
    use HasUploadImage;

    protected $maxFileSize = 5 * 1024 * 1024; // 5MB
    protected $allowedMimes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];

    public function __construct()
    {
        $this->model = Product::class;
        $this->viewPath = 'admin.components.crud';
        $this->route = 'admin.products';
        parent::__construct();
    }

    public function create()
    {
        $fields = $this->model::getFields();
        $attributes = Attribute::with('values')->get();
        $attributeValues = AttributeValue::all();

        // Debug for testing
        if ($attributes->isEmpty()) {
            dump('No attributes found. Please check your database.');
        } else {
            foreach ($attributes as $attr) {
                if ($attr->values->isEmpty()) {
                    // dump('No values found for attribute: ' . $attr->name);
                }
            }
        }

        return view('admin.components.product.form', [
            'fields' => $fields,
            'route' => $this->route,
            'attributes' => $attributes,
            'attributeValues' => $attributeValues
        ]);
    }

    protected function generateSKU($name)
    {
        // Remove special characters and convert to uppercase
        $base = strtoupper(preg_replace('/[^A-Za-z0-9]/', '', $name));

        // Take first 6 characters
        $base = substr($base, 0, 6);

        // Add random number
        $random = mt_rand(1000, 9999);

        $sku = $base . $random;

        // Check if SKU exists
        while (Product::where('sku', $sku)->exists()) {
            $random = mt_rand(1000, 9999);
            $sku = $base . $random;
        }

        return $sku;
    }

    public function store(Request $request)
    {
        $validated = $request->validate($this->model::rules());
        $validated['sku'] = $this->generateSKU($validated['name']);

        // Begin transaction
        DB::beginTransaction();

        try {
            // Create the product - slug will be auto-generated by HasSlug trait
            $product = $this->model::create($validated);

            // Handle product images
            if ($request->hasFile('images')) {
                $images = $request->file('images');
                foreach ($images as $index => $image) {
                    if (!$image->isValid()) {
                        throw new \Exception('Invalid image file at index ' . $index);
                    }
                    if (!in_array($image->getMimeType(), $this->allowedMimes)) {
                        throw new \Exception('Invalid image type at index ' . $index . ': ' . $image->getMimeType());
                    }
                    try {
                        
                        $imagePath = $image->store('products', 'public');
                        ProductImage::create([
                            'product_id' => $product->id,
                            'image_path' => $imagePath,
                            'is_primary' => $index === 0,
                            'order' => $index
                        ]);
                    } catch (\Exception $e) {
                        throw new \Exception('Failed to store image: ' . $e->getMessage());
                    }
                }
            }

            // Handle product variations
            if ($request->has('generated_variations') && !empty($request->input('generated_variations'))) {
                Log::info('Processing generated variations directly from request');
                $this->handleProductVariants($request->input('variants'), $product, $request->input('generated_variations'));
            } else if ($request->has('variants') && !empty($request->input('variants'))) {
                // Fall back to old method if no generated_variations
                $this->handleProductVariants($request->input('variants'), $product);
            }

            DB::commit();

            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => true,
                    'message' => 'Product created successfully',
                    'redirect' => route('admin.products.index'),
                    'product' => $product
                ]);
            }

            return redirect()->route($this->route . '.index')
                ->with('success', 'Product created successfully!');

        } catch (\Exception $e) {
            DB::rollBack();
            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => false,
                    'message' => 'Error creating product: ' . $e->getMessage()
                ], 500);
            }

            return redirect()->back()
                ->with('error', 'Error creating product: ' . $e->getMessage())
                ->withInput();
        }
    }

    public function edit($id)
    {
        $item = $this->model::with(['images', 'variations.attributeValues.attribute', 'variations.orderItems'])->findOrFail($id);
        $fields = $this->model::getFields();
        $attributes = Attribute::with('values')->get();
        $attributeValues = AttributeValue::all();

        // Lấy danh sách biến thể đã được mua
        $purchasedVariationIds = [];
        foreach ($item->variations as $variation) {
            if ($variation->orderItems && $variation->orderItems->count() > 0) {
                $purchasedVariationIds[] = $variation->id;
            }
        }

        // Debug log for variations
        $debug_variations = [];
        foreach ($item->variations as $variation) {
            $debug_attributes = [];
            foreach ($variation->attributeValues as $attributeValue) {
                $debug_attributes[] = [
                    'id' => $attributeValue->id,
                    'value' => $attributeValue->value,
                    'attribute_id' => $attributeValue->attribute_id,
                    'attribute_name' => $attributeValue->attribute ? $attributeValue->attribute->name : 'null'
                ];
            }
            $debug_variations[] = [
                'id' => $variation->id,
                'name' => $variation->name,
                'attribute_values' => $debug_attributes,
                'is_purchased' => in_array($variation->id, $purchasedVariationIds)
            ];
        }
        Log::info('Variation data debug:', ['variations' => $debug_variations]);

        // Prepare existing variants data for the UI
        $existingVariantsData = [];

        // Group variations by attribute
        $attributeValuesMap = [];

        foreach ($item->variations as $variation) {
            foreach ($variation->attributeValues as $attributeValue) {
                $attributeId = $attributeValue->attribute_id;
                if (!$attributeValue->attribute) {
                    $attribute = Attribute::find($attributeId);
                    $attributeName = $attribute ? $attribute->name : 'Unknown';
                } else {
                    $attributeName = $attributeValue->attribute->name;
                }
                if (!isset($attributeValuesMap[$attributeId])) {
                    $attributeValuesMap[$attributeId] = [
                        'attribute_id' => $attributeId,
                        'attribute_name' => $attributeName,
                        'values' => []
                    ];
                }
                $valueExists = false;
                foreach ($attributeValuesMap[$attributeId]['values'] as $value) {
                    if ($value['id'] == $attributeValue->id) {
                        $valueExists = true;
                        break;
                    }
                }

                if (!$valueExists) {
                    $attributeValuesMap[$attributeId]['values'][] = [
                        'id' => $attributeValue->id,
                        'value' => $attributeValue->value
                    ];
                }
            }
        }

        // Convert to array
        $existingVariantsData = array_values($attributeValuesMap);
        
        // Build the existingGeneratedVariations data structure expected by the JS
        $existingGeneratedVariations = [];
        
        foreach ($item->variations as $variation) {
            if ($variation->attributeValues->isEmpty()) {
                continue; // Skip variations with no attribute values
            }
            
            $combinationArray = [];
            foreach ($variation->attributeValues as $attributeValue) {
                $combinationArray[] = [
                    'attribute_id' => $attributeValue->attribute_id,
                    'attribute_name' => $attributeValue->attribute ? $attributeValue->attribute->name : 'Unknown',
                    'value_id' => $attributeValue->id,
                    'value' => $attributeValue->value
                ];
            }
            
            // Generate an ID for the variation similar to the JS generateVariationId function
            $variationId = implode('_', array_map(function($attr) {
                return $attr['attribute_id'] . '-' . $attr['value_id'];
            }, $combinationArray));
            
            $existingGeneratedVariations[] = [
                'id' => $variationId,
                'combination' => $combinationArray,
                'variation_id' => $variation->id,
                'is_purchased' => in_array($variation->id, $purchasedVariationIds)
            ];
        }

        return view('admin.components.product.form', [
            'item' => $item,
            'fields' => $fields,
            'route' => $this->route,
            'attributes' => $attributes,
            'attributeValues' => $attributeValues,
            'existingVariantsData' => $existingVariantsData,
            'existingGeneratedVariations' => $existingGeneratedVariations,
            'purchasedVariationIds' => $purchasedVariationIds,
            'isReadOnly' => !empty($purchasedVariationIds) // If any variation was purchased, make it readonly
        ]);
    }

    /**
     * Process image upload for a product
     * @param \Illuminate\Http\UploadedFile $image
     * @param int $productId
     * @param int $order
     * @throws \Exception
     * @return string
     */
    protected function processProductImage($image, $productId, $order)
    {
        if (!$image->isValid()) {
            throw new \Exception('Invalid image file');
        }

        if (!in_array($image->getMimeType(), $this->allowedMimes)) {
            throw new \Exception('Invalid image type: ' . $image->getMimeType());
        }

        if ($image->getSize() > $this->maxFileSize) {
            throw new \Exception('File size too large. Maximum size is 5MB');
        }

        // Store image with a unique name
        $fileName = uniqid('product_') . '_' . time() . '.' . $image->getClientOriginalExtension();
        $imagePath = $image->storeAs('products', $fileName, 'public');
        
        if (!$imagePath) {
            throw new \Exception('Failed to store image');
        }

        Log::info('Stored image at: ' . $imagePath);

        // Create product image record
        ProductImage::create([
            'product_id' => $productId,
            'image_path' => $imagePath,
            'is_primary' => false,
            'order' => $order
        ]);

        return $imagePath;
    }

    /**
     * Handle primary image selection
     * @param int $productId
     * @param string $primaryImageId
     */
    protected function handlePrimaryImageSelection($productId, $primaryImageId)
    {
        // First, set all images as non-primary
        ProductImage::where('product_id', $productId)->update(['is_primary' => false]);
        
        // Then set the selected image as primary
        if (strpos($primaryImageId, 'new_') === 0) {
            // It's a newly uploaded image, get the latest
            $latestImage = ProductImage::where('product_id', $productId)
                ->orderBy('created_at', 'desc')
                ->first();
            
            if ($latestImage) {
                $latestImage->update(['is_primary' => true]);
            }
        } else {
            // Verify the image belongs to this product before updating
            $image = ProductImage::where('id', $primaryImageId)
                ->where('product_id', $productId)
                ->first();
                
            if ($image) {
                $image->update(['is_primary' => true]);
            }
        }
    }

    /**
     * Handle image removal
     * @param int $productId
     * @param array $removeImages
     */
    protected function handleImageRemoval($productId, $removeImages)
    {
        foreach ($removeImages as $imageId) {
            if (!empty($imageId)) {
                // Verify the image belongs to this product before deleting
                $image = ProductImage::where('id', $imageId)
                    ->where('product_id', $productId)
                    ->first();
                    
                if ($image) {
                    if ($image->image_path && Storage::disk('public')->exists($image->image_path)) {
                        Storage::disk('public')->delete($image->image_path);
                    }
                    $image->delete();
                }
            }
        }

        // Ensure there's a primary image
        $primaryExists = ProductImage::where('product_id', $productId)
            ->where('is_primary', true)
            ->exists();

        if (!$primaryExists) {
            $firstImage = ProductImage::where('product_id', $productId)->first();
            if ($firstImage) {
                $firstImage->update(['is_primary' => true]);
            }
        }
    }

    protected function handleImageUpdate(Request $request, $item, array $validated)
    {
        if (!$item || !$item->id) {
            throw new \Exception('Invalid item provided for image update');
        }

        $productId = $item->id;
        Log::info('Starting image update for product ' . $productId);

        try {
            // Handle new image uploads
            if ($request->hasFile('images')) {
                $images = $request->file('images');
                Log::info('Processing ' . count($images) . ' uploaded image files');

                // Validate each image
                foreach ($images as $index => $image) {
                    if (!$image->isValid()) {
                        throw new \Exception('Invalid image file at index ' . $index);
                    }

                    if (!in_array($image->getMimeType(), ['image/jpeg', 'image/png', 'image/gif', 'image/webp'])) {
                        throw new \Exception('Invalid image type at index ' . $index . ': ' . $image->getMimeType());
                    }

                    if ($image->getSize() > 5 * 1024 * 1024) { // 5MB
                        throw new \Exception('Image file too large at index ' . $index . '. Maximum size is 5MB');
                    }
                }

                // Process each image after validation
                foreach ($images as $index => $image) {
                    try {
                        $order = ProductImage::where('product_id', $productId)->max('order');
                        $order = $order ? $order + 1 : 0;
                        
                        // Store image with a unique name
                        $fileName = uniqid('product_') . '_' . time() . '.' . $image->getClientOriginalExtension();
                        $imagePath = $image->storeAs('products', $fileName, 'public');
                        
                        if (!$imagePath) {
                            throw new \Exception('Failed to store image at index ' . $index);
                        }

                        Log::info('Stored image at: ' . $imagePath);

                        // Create product image record
                        $productImage = ProductImage::create([
                            'product_id' => $productId,
                            'image_path' => $imagePath,
                            'is_primary' => false,
                            'order' => $order
                        ]);

                        Log::info('Created product image record: ' . $productImage->id);
                    } catch (\Exception $e) {
                        Log::error('Failed to process image at index ' . $index . ': ' . $e->getMessage());
                        throw $e;
                    }
                }
            } else {
                Log::info('No new images to process');
            }

            // Handle primary image selection
            if ($request->has('primary_image')) {
                $primaryImageId = $request->input('primary_image');
                Log::info('Setting primary image: ' . $primaryImageId);
                $this->handlePrimaryImageSelection($productId, $primaryImageId);
            }

            // Handle removing images
            if ($request->has('remove_images')) {
                $removeImages = array_filter($request->remove_images); // Remove empty values
                if (!empty($removeImages)) {
                    Log::info('Removing images: ' . implode(', ', $removeImages));
                    $this->handleImageRemoval($productId, $removeImages);
                }
            }

            return true;
        } catch (\Exception $e) {
            Log::error('Error handling image update: ' . $e->getMessage(), [
                'product_id' => $productId,
                'trace' => $e->getTraceAsString()
            ]);
            throw $e;
        }
    }

    public function update(Request $request, $id)
    {
        $item = $this->model::findOrFail($id);
        $validated = $request->validate($this->model::rules($id));

        // Begin transaction
        DB::beginTransaction();

        try {
            // Update the product
            $item->update($validated);

            // Handle all image operations
            $this->handleImageUpdate($request, $item, $validated);

            // Handle product variations using handleProductVariants method
            if ($request->has('generated_variations') && !empty($request->input('generated_variations'))) {
                $this->handleProductVariants($request->input('variants'), $item, $request->input('generated_variations'));
            } elseif ($request->has('variants') && !empty($request->input('variants'))) {
                $this->handleProductVariants($request->input('variants'), $item);
            }

            DB::commit();

            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => true,
                    'message' => 'Product updated successfully',
                    'redirect' => route('admin.products.index'),
                    'product' => $item->fresh()
                ]);
            }

            return redirect()->route($this->route . '.index')
                ->with('success', 'Product updated successfully!');
        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('Error updating product: ' . $e->getMessage(), [
                'trace' => $e->getTraceAsString()
            ]);

            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => false,
                    'message' => 'Error updating product: ' . $e->getMessage()
                ], 500);
            }

            return redirect()->back()
                ->with('error', 'Error updating product: ' . $e->getMessage())
                ->withInput();
        }
    }

    public function destroy($id)
    {
        $item = $this->model::findOrFail($id);
        
        // Delete all associated product images
        $images = ProductImage::where('product_id', $item->id)->get();
        foreach ($images as $image) {
            if ($image->image_path && Storage::disk('public')->exists($image->image_path)) {
                Storage::disk('public')->delete($image->image_path);
            }
            $image->delete();
        }
        
        $item->delete();

        return redirect()->route($this->route . '.index')
            ->with('success', 'Product moved to trash successfully!');
    }

    /**
     * Generate all possible combinations of attribute values for product variations
     *
     * @param array $variantsData An array of variant options with their attribute values
     * @return array All possible combinations of attribute values
     */
    protected function generateVariantCombinations(array $variantsData)
    {
        if (empty($variantsData)) {
            return [];
        }

        Log::info('Generating combinations from variants data:', ['data' => $variantsData]);

        // Extract values from each option
        $valueSets = [];
        foreach ($variantsData as $variant) {
            if (!isset($variant['values']) || empty($variant['values'])) {
                Log::warning('No values found for variant:', ['variant' => $variant]);
                continue;
            }
            $valueSets[] = $variant['values'];
        }

        if (empty($valueSets)) {
            Log::warning('No valid value sets found');
            return [];
        }

        Log::info('Value sets prepared:', ['sets' => $valueSets]);

        // Generate combinations using recursive function
        $combinations = $this->generateCombinations($valueSets);
        Log::info('Generated combinations:', ['count' => count($combinations), 'combinations' => $combinations]);

        return $combinations;
    }

    private function generateCombinations(array $arrays, $i = 0)
    {
        if (!isset($arrays[$i])) {
            return [];
        }
        if ($i == count($arrays) - 1) {
            return array_map(function ($item) {
                return [$item];
            }, $arrays[$i]);
        }

        // Get combinations from subsequent arrays
        $tmp = $this->generateCombinations($arrays, $i + 1);

        $result = [];
        foreach ($arrays[$i] as $v) {
            foreach ($tmp as $t) {
                $result[] = array_merge([$v], $t);
            }
        }

        return $result;
    }

    protected function handleProductImages($images, $product)
    {
        foreach ($images as $index => $image) {
            // Validate image
            if (!$image->isValid()) {
                throw new \Exception('Invalid image file at index ' . $index);
            }

            if (!in_array($image->getMimeType(), ['image/jpeg', 'image/png', 'image/gif', 'image/webp'])) {
                throw new \Exception('Invalid image type at index ' . $index . ': ' . $image->getMimeType());
            }

            // Store image
            try {
                $imagePath = $image->store('products', 'public');
                Log::info('Stored image at: ' . $imagePath);

                // Create product image record
                ProductImage::create([
                    'product_id' => $product->id,
                    'image_path' => $imagePath,
                    'is_primary' => $index === 0 && $product->images()->count() === 0,
                    'order' => $index
                ]);
            } catch (\Exception $e) {
                Log::error('Failed to store image: ' . $e->getMessage());
                throw new \Exception('Failed to store image: ' . $e->getMessage());
            }
        }
    }

    protected function handleImageRemovals($removeImages, $product)
    {
        foreach ($removeImages as $imageId) {
            if (!empty($imageId)) {
                $image = ProductImage::find($imageId);
                if ($image && $image->product_id === $product->id) {
                    // Delete the physical file
                    if (Storage::disk('public')->exists($image->image_path)) {
                        Storage::disk('public')->delete($image->image_path);
                    }
                    $image->delete();
                }
            }
        }
    }

    protected function handleProductVariants($variantsData, $product, $generatedVariationsJson = null)
    {
        $variantsArray = is_string($variantsData) ? json_decode($variantsData, true) : $variantsData;
        $generatedVariationsJson = $generatedVariationsJson ?? request()->input('generated_variations');
        $generatedVariations = [];
        if (!empty($generatedVariationsJson)) {
            try {
                $generatedVariations = json_decode($generatedVariationsJson, true);
                if (json_last_error() !== JSON_ERROR_NONE) {
                    Log::error('JSON decode error in handleProductVariants method:', ['error' => json_last_error_msg()]);
                }
            } catch (\Exception $e) {
                Log::error('Exception in handleProductVariants when decoding JSON:', ['error' => $e->getMessage()]);
            }
        }

        if (!empty($generatedVariations) && is_array($generatedVariations)) {
            try {
                DB::beginTransaction();
                $existingVariations = ProductVariation::where('product_id', $product->id)
                    ->with(['attributeValues', 'orderItems'])
                    ->get();
                $existingVariationMap = [];
                foreach ($existingVariations as $variation) {
                    $attributeValueIds = $variation->attributeValues->pluck('id')->sort()->implode('_');
                    $existingVariationMap[$attributeValueIds] = $variation;
                }
                $purchasedVariations = [];
                foreach ($existingVariations as $variation) {
                    if ($variation->orderItems->count() > 0) {
                        $purchasedVariations[$variation->id] = true;
                    }
                }
                $variationsToKeep = [];
                $timestamp = now()->format('His');
                foreach ($generatedVariations as $variation) {
                    if (!isset($variation['id']) || !isset($variation['combination'])) {
                        continue;
                    }

                    if (isset($variation['variation_id']) && isset($purchasedVariations[$variation['variation_id']])) {
                        $variationsToKeep[] = $variation['variation_id'];
                        continue;
                    }
                    $attributeValueIds = [];
                    $variationName = $product->name;
                    $skuParts = [];
                    foreach ($variation['combination'] as $attrValue) {
                        $valueId = $attrValue['value_id'] ?? $attrValue['id'];
                        $attributeValueIds[] = $valueId;
                        $variationName .= ' - ' . $attrValue['value'];
                        $skuParts[] = substr(strtoupper(preg_replace('/[^A-Za-z0-9]/', '', $attrValue['value'])), 0, 3);
                    }
                    sort($attributeValueIds);
                    $combinationSignature = implode('_', $attributeValueIds);
                    if (isset($existingVariationMap[$combinationSignature])) {
                        $existingVariation = $existingVariationMap[$combinationSignature];
                        $variationsToKeep[] = $existingVariation->id;
                        continue;
                    }
                    $skuBase = $product->sku . '-' . implode('-', $skuParts);
                    $variationSku = $skuBase . '-' . $timestamp;
                    $counter = 1;
                    while (ProductVariation::where('sku', $variationSku)->exists()) {
                        $variationSku = $skuBase . '-' . $timestamp . '-' . $counter;
                        $counter++;
                    }
                    $newVariation = ProductVariation::create([
                        'product_id' => $product->id,
                        'sku' => $variationSku,
                        'name' => $variationName,
                        'price' => 0,
                        'sale_price' => 0,
                        'stock' => 0
                    ]);
                    if (!empty($attributeValueIds)) {
                        $newVariation->attributeValues()->attach($attributeValueIds);
                    }
                    $variationsToKeep[] = $newVariation->id;
                }
                $deletedCount = ProductVariation::where('product_id', $product->id)
                    ->whereNotIn('id', $variationsToKeep)
                    ->whereNotIn('id', array_keys($purchasedVariations))
                    ->delete();
                DB::commit();
            } catch (\Exception $e) {
                DB::rollBack();
                throw $e;
            }
        } else {
            // Process traditional variants format if generated_variations is empty
            Log::info('Processing traditional variants format for product ID ' . $product->id);
            
            if (!empty($variantsArray) && is_array($variantsArray)) {
                try {
                    // Generate combinations from traditional format
                    $combinations = $this->generateVariantCombinations($variantsArray);
                    
                    if (!empty($combinations)) {
                        DB::beginTransaction();
                        
                        foreach ($combinations as $combination) {
                            $variationName = $product->name;
                            $skuSuffix = '';
                            $attributeValueIds = [];
                            
                            foreach ($combination as $attributeValue) {
                                if (!isset($attributeValue['id']) || !isset($attributeValue['value'])) {
                                    continue;
                                }
                                
                                $variationName .= ' - ' . $attributeValue['value'];
                                $skuSuffix .= '-' . substr(strtoupper(preg_replace('/[^A-Za-z0-9]/', '', $attributeValue['value'])), 0, 3);
                                $attributeValueIds[] = $attributeValue['id'];
                            }
                            
                            if (empty($attributeValueIds)) {
                                continue;
                            }
                            
                            // Generate variation SKU
                            $variationSku = $product->sku . $skuSuffix;
                            $counter = 1;
                            while (ProductVariation::where('sku', $variationSku)->exists()) {
                                $variationSku = $product->sku . $skuSuffix . '-' . $counter;
                                $counter++;
                            }
                            
                            // Create variation
                            $newVariation = ProductVariation::create([
                                'product_id' => $product->id,
                                'sku' => $variationSku,
                                'name' => $variationName,
                                'price' => 0,
                                'sale_price' => 0,
                                'stock' => 0
                            ]);
                            
                            // Attach attribute values
                            if (!empty($attributeValueIds)) {
                                $newVariation->attributeValues()->attach($attributeValueIds);
                            }
                        }
                        
                        DB::commit();
                        Log::info('Successfully created variations from traditional format for product ' . $product->id);
                    }
                } catch (\Exception $e) {
                    if (isset($newVariation)) {
                        DB::rollBack();
                    }
                    Log::error('Error processing traditional variations format:', [
                        'product_id' => $product->id,
                        'message' => $e->getMessage(),
                        'trace' => $e->getTraceAsString()
                    ]);
                }
            } else {
                Log::info('No variants data available for product ' . $product->id);
            }
        }
    }
}
