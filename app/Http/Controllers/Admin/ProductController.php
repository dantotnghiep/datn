<?php

namespace App\Http\Controllers\Admin;

use App\Models\Product;
use App\Models\Category;
use App\Models\ProductImage;
use App\Models\ProductVariation;
use App\Models\Attribute;
use App\Models\AttributeValue;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use App\Http\Controllers\Admin\Traits\HasUploadImage;

class ProductController extends BaseController
{
    use HasUploadImage;

    public function __construct()
    {
        $this->model = Product::class;
        $this->viewPath = 'admin.components.crud';
        $this->route = 'admin.products';
        parent::__construct();
    }

    public function create()
    {
        $fields = $this->model::getFields();
        $attributes = Attribute::with('values')->get();
        $attributeValues = AttributeValue::all();

        // Debug for testing
        if ($attributes->isEmpty()) {
            dump('No attributes found. Please check your database.');
        } else {
            foreach ($attributes as $attr) {
                if ($attr->values->isEmpty()) {
                    // dump('No values found for attribute: ' . $attr->name);
                }
            }
        }

        return view('admin.components.product.form', [
            'fields' => $fields,
            'route' => $this->route,
            'attributes' => $attributes,
            'attributeValues' => $attributeValues
        ]);
    }

    protected function generateSKU($name)
    {
        // Remove special characters and convert to uppercase
        $base = strtoupper(preg_replace('/[^A-Za-z0-9]/', '', $name));

        // Take first 6 characters
        $base = substr($base, 0, 6);

        // Add random number
        $random = mt_rand(1000, 9999);

        $sku = $base . $random;

        // Check if SKU exists
        while (Product::where('sku', $sku)->exists()) {
            $random = mt_rand(1000, 9999);
            $sku = $base . $random;
        }

        return $sku;
    }

    public function store(Request $request)
    {
        $validated = $request->validate($this->model::rules());
        $validated['sku'] = $this->generateSKU($validated['name']);

        // Begin transaction
        DB::beginTransaction();

        try {
            // Create the product - slug will be auto-generated by HasSlug trait
            $product = $this->model::create($validated);
            Log::info('Product created successfully', ['product_id' => $product->id]);

            // Handle product images
            if ($request->hasFile('images')) {
                $images = $request->file('images');
                foreach ($images as $index => $image) {
                    if (!$image->isValid()) {
                        throw new \Exception('Invalid image file at index ' . $index);
                    }
                    if (!in_array($image->getMimeType(), ['image/jpeg', 'image/png', 'image/gif', 'image/webp'])) {
                        throw new \Exception('Invalid image type at index ' . $index . ': ' . $image->getMimeType());
                    }
                    try {
                        $imagePath = $image->store('products', 'public');
                        ProductImage::create([
                            'product_id' => $product->id,
                            'image_path' => $imagePath,
                            'is_primary' => $index === 0,
                            'order' => $index
                        ]);
                    } catch (\Exception $e) {
                        throw new \Exception('Failed to store image: ' . $e->getMessage());
                    }
                }
            }

            // Handle product variations - process directly from request
            if ($request->has('generated_variations') && !empty($request->input('generated_variations'))) {
                Log::info('Processing generated variations directly from request');
                try {
                    $generatedVariations = json_decode($request->input('generated_variations'), true);
                    
                    if (json_last_error() !== JSON_ERROR_NONE) {
                        Log::error('JSON decode error in store method:', ['error' => json_last_error_msg()]);
                    }
                    
                    if (!empty($generatedVariations) && is_array($generatedVariations)) {
                        Log::info('Creating variations for new product', [
                            'product_id' => $product->id,
                            'variations_count' => count($generatedVariations)
                        ]);
                        
                        // Create variations
                        $createdCount = 0;
                        foreach ($generatedVariations as $variation) {
                            if (!isset($variation['id']) || !isset($variation['combination'])) {
                                Log::warning('Skipping invalid variation data', ['variation' => $variation]);
                                continue;
                            }
                            
                            $variationName = $product->name;
                            $skuSuffix = '';
                            $attributeValueIds = [];
                            
                            // Process each attribute in the combination
                            foreach ($variation['combination'] as $attrValue) {
                                if (!isset($attrValue['value_id']) || !isset($attrValue['value'])) {
                                    Log::warning('Invalid attribute value', ['value' => $attrValue]);
                                    continue;
                                }
                                
                                $variationName .= ' - ' . $attrValue['value'];
                                $skuSuffix .= '-' . substr(strtoupper(preg_replace('/[^A-Za-z0-9]/', '', $attrValue['value'])), 0, 3);
                                $attributeValueIds[] = $attrValue['value_id'];
                            }
                            
                            if (empty($attributeValueIds)) {
                                Log::warning('No valid attribute values for variation', ['variation' => $variation]);
                                continue;
                            }
                            
                            // Generate variation SKU
                            $variationSku = $product->sku . $skuSuffix;
                            $counter = 1;
                            while (ProductVariation::where('sku', $variationSku)->exists()) {
                                $variationSku = $product->sku . $skuSuffix . '-' . $counter;
                                $counter++;
                            }
                            
                            // Create variation
                            $newVariation = ProductVariation::create([
                                'product_id' => $product->id,
                                'sku' => $variationSku,
                                'name' => $variationName,
                                'price' => 0,
                                'sale_price' => 0,
                                'stock' => 0
                            ]);
                            $createdCount++;
                            
                            // Attach attribute values
                            if (!empty($attributeValueIds)) {
                                $newVariation->attributeValues()->attach($attributeValueIds);
                            }
                        }
                        
                        Log::info("Successfully created {$createdCount} variations for product {$product->id}");
                    } else {
                        Log::info('No valid variations data to process after JSON decode');
                    }
                } catch (\Exception $e) {
                    Log::error('Error processing variations in store method:', [
                        'message' => $e->getMessage(),
                        'trace' => $e->getTraceAsString()
                    ]);
                    // Continue even if variations fail - don't throw the exception
                }
            } else if ($request->has('variants') && !empty($request->variants)) {
                // Fall back to old method if no generated_variations
                Log::info('Falling back to variants data processing');
                $this->handleProductVariants($request->variants, $product);
            }

            DB::commit();

            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => true,
                    'message' => 'Product created successfully',
                    'redirect' => route('admin.products.index'),
                    'product' => $product
                ]);
            }

            return redirect()->route($this->route . '.index')
                ->with('success', 'Product created successfully!');

        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('Error creating product: ' . $e->getMessage(), [
                'trace' => $e->getTraceAsString()
            ]);

            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => false,
                    'message' => 'Error creating product: ' . $e->getMessage()
                ], 500);
            }

            return redirect()->back()
                ->with('error', 'Error creating product: ' . $e->getMessage())
                ->withInput();
        }
    }

    public function edit($id)
    {
        $item = $this->model::with(['images', 'variations.attributeValues.attribute', 'variations.orderItems'])->findOrFail($id);
        $fields = $this->model::getFields();
        $attributes = Attribute::with('values')->get();
        $attributeValues = AttributeValue::all();

        // Lấy danh sách biến thể đã được mua
        $purchasedVariationIds = [];
        foreach ($item->variations as $variation) {
            if ($variation->orderItems && $variation->orderItems->count() > 0) {
                $purchasedVariationIds[] = $variation->id;
            }
        }

        // Debug log for variations
        $debug_variations = [];
        foreach ($item->variations as $variation) {
            $debug_attributes = [];
            foreach ($variation->attributeValues as $attributeValue) {
                $debug_attributes[] = [
                    'id' => $attributeValue->id,
                    'value' => $attributeValue->value,
                    'attribute_id' => $attributeValue->attribute_id,
                    'attribute_name' => $attributeValue->attribute ? $attributeValue->attribute->name : 'null'
                ];
            }
            $debug_variations[] = [
                'id' => $variation->id,
                'name' => $variation->name,
                'attribute_values' => $debug_attributes,
                'is_purchased' => in_array($variation->id, $purchasedVariationIds)
            ];
        }
        Log::info('Variation data debug:', ['variations' => $debug_variations]);

        // Prepare existing variants data for the UI
        $existingVariantsData = [];

        // Group variations by attribute
        $attributeValuesMap = [];

        foreach ($item->variations as $variation) {
            foreach ($variation->attributeValues as $attributeValue) {
                $attributeId = $attributeValue->attribute_id;
                if (!$attributeValue->attribute) {
                    $attribute = Attribute::find($attributeId);
                    $attributeName = $attribute ? $attribute->name : 'Unknown';
                } else {
                    $attributeName = $attributeValue->attribute->name;
                }
                if (!isset($attributeValuesMap[$attributeId])) {
                    $attributeValuesMap[$attributeId] = [
                        'attribute_id' => $attributeId,
                        'attribute_name' => $attributeName,
                        'values' => []
                    ];
                }
                $valueExists = false;
                foreach ($attributeValuesMap[$attributeId]['values'] as $value) {
                    if ($value['id'] == $attributeValue->id) {
                        $valueExists = true;
                        break;
                    }
                }

                if (!$valueExists) {
                    $attributeValuesMap[$attributeId]['values'][] = [
                        'id' => $attributeValue->id,
                        'value' => $attributeValue->value
                    ];
                }
            }
        }

        // Convert to array
        $existingVariantsData = array_values($attributeValuesMap);
        
        // Build the existingGeneratedVariations data structure expected by the JS
        $existingGeneratedVariations = [];
        
        foreach ($item->variations as $variation) {
            if ($variation->attributeValues->isEmpty()) {
                continue; // Skip variations with no attribute values
            }
            
            $combinationArray = [];
            foreach ($variation->attributeValues as $attributeValue) {
                $combinationArray[] = [
                    'attribute_id' => $attributeValue->attribute_id,
                    'attribute_name' => $attributeValue->attribute ? $attributeValue->attribute->name : 'Unknown',
                    'value_id' => $attributeValue->id,
                    'value' => $attributeValue->value
                ];
            }
            
            // Generate an ID for the variation similar to the JS generateVariationId function
            $variationId = implode('_', array_map(function($attr) {
                return $attr['attribute_id'] . '-' . $attr['value_id'];
            }, $combinationArray));
            
            $existingGeneratedVariations[] = [
                'id' => $variationId,
                'combination' => $combinationArray,
                'variation_id' => $variation->id,
                'is_purchased' => in_array($variation->id, $purchasedVariationIds)
            ];
        }

        return view('admin.components.product.form', [
            'item' => $item,
            'fields' => $fields,
            'route' => $this->route,
            'attributes' => $attributes,
            'attributeValues' => $attributeValues,
            'existingVariantsData' => $existingVariantsData,
            'existingGeneratedVariations' => $existingGeneratedVariations,
            'purchasedVariationIds' => $purchasedVariationIds,
            'isReadOnly' => !empty($purchasedVariationIds) // If any variation was purchased, make it readonly
        ]);
    }

    public function update(Request $request, $id)
    {
        $item = $this->model::findOrFail($id);
        $validated = $request->validate($this->model::rules($id));

        // Begin transaction
        DB::beginTransaction();

        try {
            // Update the product
            $item->update($validated);

            // Handle product images
            if ($request->hasFile('images')) {
                $images = $request->file('images');
                Log::info('Processing ' . count($images) . ' uploaded image files');

                foreach ($images as $index => $image) {
                    // Validate image
                    if (!$image->isValid()) {
                        throw new \Exception('Invalid image file at index ' . $index);
                    }

                    if (!in_array($image->getMimeType(), ['image/jpeg', 'image/png', 'image/gif', 'image/webp'])) {
                        throw new \Exception('Invalid image type at index ' . $index . ': ' . $image->getMimeType());
                    }

                    // Store image
                    try {
                        $imagePath = $image->store('products', 'public');
                        Log::info('Stored image at: ' . $imagePath);

                        // Create product image record
                        ProductImage::create([
                            'product_id' => $id,
                            'image_path' => $imagePath,
                            'is_primary' => false,
                            'order' => ProductImage::where('product_id', $id)->max('order') + 1
                        ]);
                    } catch (\Exception $e) {
                        Log::error('Failed to store image: ' . $e->getMessage());
                        throw new \Exception('Failed to store image: ' . $e->getMessage());
                    }
                }
            }

            // Handle primary image selection
            if ($request->has('primary_image')) {
                $primaryImageId = $request->input('primary_image');
                Log::info('Setting primary image: ' . $primaryImageId);
                
                // First, set all images as non-primary
                ProductImage::where('product_id', $id)->update(['is_primary' => false]);
                
                // Then set the selected image as primary
                if (strpos($primaryImageId, 'new_') === 0) {
                    // It's a newly uploaded image, get the latest
                    $latestImage = ProductImage::where('product_id', $id)
                        ->orderBy('created_at', 'desc')
                        ->first();
                    
                    if ($latestImage) {
                        $latestImage->update(['is_primary' => true]);
                    }
                } else {
                    // It's an existing image
                    ProductImage::where('id', $primaryImageId)->update(['is_primary' => true]);
                }
            }

            // Handle removing images
            if ($request->has('remove_images')) {
                $removeImages = array_filter($request->remove_images); // Remove empty values
                foreach ($removeImages as $imageId) {
                    if (!empty($imageId)) {
                        $image = ProductImage::findOrFail($imageId);
                        if ($image->image_path) {
                            Storage::disk('public')->delete($image->image_path);
                        }
                        $image->delete();
                    }
                }

                // Ensure there's a primary image
                $primaryExists = ProductImage::where('product_id', $id)
                    ->where('is_primary', true)
                    ->exists();

                if (!$primaryExists) {
                    $firstImage = ProductImage::where('product_id', $id)->first();
                    if ($firstImage) {
                        $firstImage->update(['is_primary' => true]);
                    }
                }
            }

            // Handle product variations using handleProductVariants method
            if ($request->has('generated_variations') && !empty($request->generated_variations)) {
                $this->handleProductVariants($request->variants, $item, $request->generated_variations);
            } elseif ($request->has('variants') && !empty($request->variants)) {
                $this->handleProductVariants($request->variants, $item);
            }

            DB::commit();

            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => true,
                    'message' => 'Product updated successfully',
                    'redirect' => route('admin.products.index'),
                    'product' => $item->fresh()
                ]);
            }

            return redirect()->route($this->route . '.index')
                ->with('success', 'Product updated successfully!');
        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('Error updating product: ' . $e->getMessage(), [
                'trace' => $e->getTraceAsString()
            ]);

            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => false,
                    'message' => 'Error updating product: ' . $e->getMessage()
                ], 500);
            }

            return redirect()->back()
                ->with('error', 'Error updating product: ' . $e->getMessage())
                ->withInput();
        }
    }

    public function destroy($id)
    {
        $item = $this->model::findOrFail($id);
        $this->handleImageDelete($item, 'image');
        $item->delete();

        return redirect()->route($this->route . '.index')
            ->with('success', 'Product moved to trash successfully!');
    }

    /**
     * Generate all possible combinations of attribute values for product variations
     *
     * @param array $variantsData An array of variant options with their attribute values
     * @return array All possible combinations of attribute values
     */
    protected function generateVariantCombinations(array $variantsData)
    {
        if (empty($variantsData)) {
            return [];
        }

        Log::info('Generating combinations from variants data:', ['data' => $variantsData]);

        // Extract values from each option
        $valueSets = [];
        foreach ($variantsData as $variant) {
            if (!isset($variant['values']) || empty($variant['values'])) {
                Log::warning('No values found for variant:', ['variant' => $variant]);
                continue;
            }
            $valueSets[] = $variant['values'];
        }

        if (empty($valueSets)) {
            Log::warning('No valid value sets found');
            return [];
        }

        Log::info('Value sets prepared:', ['sets' => $valueSets]);

        // Generate combinations using recursive function
        $combinations = $this->generateCombinations($valueSets);
        Log::info('Generated combinations:', ['count' => count($combinations), 'combinations' => $combinations]);

        return $combinations;
    }

    private function generateCombinations(array $arrays, $i = 0)
    {
        if (!isset($arrays[$i])) {
            return [];
        }
        if ($i == count($arrays) - 1) {
            return array_map(function ($item) {
                return [$item];
            }, $arrays[$i]);
        }

        // Get combinations from subsequent arrays
        $tmp = $this->generateCombinations($arrays, $i + 1);

        $result = [];
        foreach ($arrays[$i] as $v) {
            foreach ($tmp as $t) {
                $result[] = array_merge([$v], $t);
            }
        }

        return $result;
    }

    protected function handleProductImages($images, $product)
    {
        foreach ($images as $index => $image) {
            // Validate image
            if (!$image->isValid()) {
                throw new \Exception('Invalid image file at index ' . $index);
            }

            if (!in_array($image->getMimeType(), ['image/jpeg', 'image/png', 'image/gif', 'image/webp'])) {
                throw new \Exception('Invalid image type at index ' . $index . ': ' . $image->getMimeType());
            }

            // Store image
            try {
                $imagePath = $image->store('products', 'public');
                Log::info('Stored image at: ' . $imagePath);

                // Create product image record
                ProductImage::create([
                    'product_id' => $product->id,
                    'image_path' => $imagePath,
                    'is_primary' => $index === 0 && $product->images()->count() === 0,
                    'order' => $index
                ]);
            } catch (\Exception $e) {
                Log::error('Failed to store image: ' . $e->getMessage());
                throw new \Exception('Failed to store image: ' . $e->getMessage());
            }
        }
    }

    protected function handleImageRemovals($removeImages, $product)
    {
        foreach ($removeImages as $imageId) {
            if (!empty($imageId)) {
                $image = ProductImage::find($imageId);
                if ($image && $image->product_id === $product->id) {
                    // Delete the physical file
                    if (Storage::disk('public')->exists($image->image_path)) {
                        Storage::disk('public')->delete($image->image_path);
                    }
                    $image->delete();
                }
            }
        }
    }

    protected function handlePrimaryImage($primaryImageId, $product)
    {
        // First, set all images as non-primary
        $product->images()->update(['is_primary' => false]);

        // Then set the selected image as primary
        if ($primaryImageId) {
            $image = ProductImage::find($primaryImageId);
            if ($image && $image->product_id === $product->id) {
                $image->update(['is_primary' => true]);
            }
        }
    }

    protected function handleProductVariants($variantsData, $product, $generatedVariationsJson = null)
    {
        if (empty($variantsData)) {
            Log::warning('No variants data provided');
            return;
        }

        // Decode variants data if it's a string
        $variantsArray = is_string($variantsData) ? json_decode($variantsData, true) : $variantsData;
        Log::info('Processing variants data:', ['data' => $variantsArray]);

        // Get generated variations data - this contains the final list of variations to create
        $generatedVariationsJson = $generatedVariationsJson ?? request()->input('generated_variations');
        Log::info('Raw generated_variations from form:', [
            'raw_data' => $generatedVariationsJson,
            'is_string' => is_string($generatedVariationsJson),
            'length' => is_string($generatedVariationsJson) ? strlen($generatedVariationsJson) : 0
        ]);
        
        // Decode the JSON more carefully
        $generatedVariations = [];
        if (!empty($generatedVariationsJson)) {
            try {
                $generatedVariations = json_decode($generatedVariationsJson, true);
                if (json_last_error() !== JSON_ERROR_NONE) {
                    Log::error('JSON decode error:', ['error' => json_last_error_msg()]);
                }
            } catch (\Exception $e) {
                Log::error('Exception decoding variations JSON:', ['message' => $e->getMessage()]);
            }
        }
        
        Log::info('Generated variations after decode:', [
            'count' => is_array($generatedVariations) ? count($generatedVariations) : 0,
            'is_array' => is_array($generatedVariations),
            'variations' => $generatedVariations
        ]);

        if (!empty($generatedVariations) && is_array($generatedVariations)) {
            try {
                DB::beginTransaction();

                // Kiểm tra các biến thể đã được mua
                $purchasedVariations = [];
                if ($product->id) {
                    $existingVariations = ProductVariation::where('product_id', $product->id)
                        ->with('orderItems')
                        ->get();
                    
                    foreach ($existingVariations as $variation) {
                        if ($variation->orderItems->count() > 0) {
                            $purchasedVariations[$variation->id] = true;
                        }
                    }
                }

                // Ghi log số lượng biến thể đã mua
                Log::info("Found " . count($purchasedVariations) . " purchased variations that cannot be deleted");

                // Nếu có biến thể đã được mua, chỉ xóa các biến thể chưa mua
                if (!empty($purchasedVariations)) {
                    $variationsToDelete = ProductVariation::where('product_id', $product->id)
                        ->whereNotIn('id', array_keys($purchasedVariations))
                        ->pluck('id')
                        ->toArray();
                    
                    $deletedCount = ProductVariation::whereIn('id', $variationsToDelete)->delete();
                } else {
                    // Không có biến thể nào đã mua, xóa tất cả
                    $deletedCount = ProductVariation::where('product_id', $product->id)->delete();
                }
                
                Log::info("Deleted {$deletedCount} existing variations for product {$product->id}");

                // Only create variations that exist in the generated_variations field
                $createdCount = 0;
                foreach ($generatedVariations as $variation) {
                    if (!isset($variation['id']) || !isset($variation['combination'])) {
                        Log::warning('Skipping invalid variation data', ['variation' => $variation]);
                        continue;
                    }

                    // Kiểm tra nếu biến thể này có variation_id và đã được mua thì bỏ qua
                    if (isset($variation['variation_id']) && isset($purchasedVariations[$variation['variation_id']])) {
                        Log::info("Skipping purchased variation: " . $variation['variation_id']);
                        continue;
                    }

                    $variationName = $product->name;
                    $skuSuffix = '';
                    $attributeValueIds = [];

                    // Process each attribute in the combination
                    foreach ($variation['combination'] as $attrValue) {
                        if (!isset($attrValue['value_id']) && !isset($attrValue['id'])) {
                            Log::warning('Invalid attribute value', ['value' => $attrValue]);
                            continue;
                        }

                        $valueId = $attrValue['value_id'] ?? $attrValue['id'];
                        $variationName .= ' - ' . $attrValue['value'];
                        $skuSuffix .= '-' . substr(strtoupper(preg_replace('/[^A-Za-z0-9]/', '', $attrValue['value'])), 0, 3);
                        $attributeValueIds[] = $valueId;
                    }

                    if (empty($attributeValueIds)) {
                        Log::warning('No valid attribute values for variation', ['variation' => $variation]);
                        continue;
                    }

                    // Generate variation SKU
                    $variationSku = $product->sku . $skuSuffix;
                    $counter = 1;
                    while (ProductVariation::where('sku', $variationSku)->exists()) {
                        $variationSku = $product->sku . $skuSuffix . '-' . $counter;
                        $counter++;
                    }

                    // Create variation
                    $newVariation = ProductVariation::create([
                        'product_id' => $product->id,
                        'sku' => $variationSku,
                        'name' => $variationName,
                        'price' => 0,
                        'sale_price' => 0,
                        'stock' => 0
                    ]);
                    $createdCount++;

                    Log::info('Created variation:', [
                        'id' => $newVariation->id,
                        'sku' => $variationSku,
                        'name' => $variationName,
                        'attribute_values' => $attributeValueIds
                    ]);

                    // Attach attribute values
                    if (!empty($attributeValueIds)) {
                        $newVariation->attributeValues()->attach($attributeValueIds);
                    }
                }

                Log::info("Created {$createdCount} variations for product {$product->id}");
                DB::commit();
            } catch (\Exception $e) {
                DB::rollBack();
                Log::error('Error processing variants:', [
                    'message' => $e->getMessage(),
                    'trace' => $e->getTraceAsString()
                ]);
                throw $e;
            }
        } else {
            Log::info('No generated variations to process');
        }
    }
}
